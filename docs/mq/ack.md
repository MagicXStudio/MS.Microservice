# 消费确认和发布确认（ACK）

这篇文章主要阐述下面几个观点（注意以下 ACK 都指 Acknowledgement ）

- 为什么需要 ACK 的存在
- 手动与自动确认的模式
- ACK API，包括“多ACK”以及重入队列
- 在连接丢失或 channel 关闭之上自动重入队列
- Channel 预先加载与高吞吐的影响
- 常见的客户端错误
- 发布确认和与发布者发布数据安全相关的话题

还有很多，总之在应用程序中的使用消息， ACK 是对消费者和发布者两者的数据安全都非常重要的。

## 基础

像 RabbitMQ 这样使用一个消息 broker 是被定义为分布式系统。因为这个协议方法不能保证每个消息请求都能成功处理，所以消费者和发布者两个都需要一个派送和处理确认的机制。RabbitMQ 在很多消息协议上已经提供支持这些特性了。

从客户机到 RabbitMQ 的派送处理确认在消息协议里被称为确认。对发布者的代理确认（broker ack）是一个协议拓展，被称为发布者确认（publisher confirms）。它们的特征都是受到了 TCP 的启发。

对于从发布者到 RabbitMQ 节点的可靠交付以及从 RabbitMQ 到消费者的可靠交付都是非常必要的。换句话说，它们对数据安全至关重要，而应用程序对数据安全的责任与 RabbitMQ 节点的责任是一样的。

## （消费者）交付确认

当 RabbitMQ 递送一个消息给消费者时，它需要知道这个消息何时发送成功了。什么样的逻辑最优这是取决于系统。这主要是由应用程序决定。在 AMPQ 0-9-1 中就是由一个消费者通过使用 `basic.consume` 方法或使用 `basic.get` 方法按需提取一个消息时生成的。

## 递送标识符：递送的标签

在我们着手讨论其他话题之前，去解释是如何识别递送的（确认表示它们各自的推送）。当消费者（订阅者）注册时，消息就会被 RabbitMQ 通过方法 `basic.deliver` 推送过去。这个方法就会被标记上推送标签（deliver tag），它在 channel 上表示唯一的标识。因此推送标识作用在每个 channel 内。

推送标签是单调增长的正整数，并由客户端库表示。客户端库方法会接受一个推送标签作为参数确认推送。

由于推送标签只作用在每个 channel 内，推送必须在接收它们的同一通道上得到确认。在不同的 channel 上确认会得到“未知的推送标签”协议异常并会关闭 channel。